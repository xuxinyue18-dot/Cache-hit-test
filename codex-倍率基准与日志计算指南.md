# Codex 倍率（基准词）与日志计算指南

本文给出一套**可复现、可对比、可落地**的“真实倍率”定义，并说明如何通过 Codex 本地日志（rollout JSONL）模拟用户行为、采集数据、计算倍率。

> 适用场景：你想把「价格 + 缓存 + 输入/输出 token」统一起来，得到一个**客观、可跨天对比**的倍率指标，而不是单纯的“输出价/输入价”。

---

## 1. 数据源：用哪个日志算？

Codex 在本机常见两类记录：

- `~/.codex/log/codex-tui.log`
  - 更像运行时日志（ToolCall 记录较多）
  - **通常不完整包含 tool output，也不一定包含 token 统计细节**
- `~/.codex/sessions/YYYY/MM/DD/rollout-*.jsonl`
  - **强烈推荐用它做计算**
  - 内含 `token_count` 事件（`input_tokens` / `cached_input_tokens` / `output_tokens` 等）
  - 内含工具调用的结构化记录（function_call / function_call_output）

本文所有“倍率”计算以 `rollout-*.jsonl` 为准。

---

## 2. 基准词（Baseline Token）定义

先把计费单位统一到一个“基准词”上，便于比较。

设：

- `Pin`：输入单价（$/1M tokens）
- `Pout`：输出单价（$/1M tokens）
- `α`：缓存输入折扣系数（**缓存输入单价 / 普通输入单价**）
  - 不打折：`α = 1`
  - 缓存按 0.1 计费：`α = 0.1`
- `r = Pout / Pin`：输出相对输入的价格倍率

从日志中取 token：

- `I = input_tokens`（总输入 token）
- `C = cached_input_tokens`（命中缓存的输入 token）
- `U = I - C`（未命中/新增输入 token）
- `O = output_tokens`（输出 token）

### 2.1 等价基准词（把成本折到输入侧）

定义“等价基准词”（Equivalent Baseline Tokens）：

`E = U + α*C + r*O`

解释：

- `U`：新增输入按输入价计费（基准）
- `α*C`：缓存输入按折扣计费
- `r*O`：把输出成本折算成“等价输入 token”

---

## 3. 真实倍率（推荐口径）

你需要一个分母来代表“有效工作量”。我推荐默认用：

- **有效工作词**：`W = U + O`
  - 理由：`U` 是你真正新增输入；`O` 是你真正产生的输出（产出本身也算工作量的一部分）

则 **真实倍率** 定义为：

`M = E / W`

直觉解释：

- `M = 1×`：说明“你的总花费”≈“如果把新增输入+输出都按输入价算的花费”
- `M > 1×`：说明成本压力更大（通常来自输出贵、或缓存折扣小）
- `M < 1×`：一般意味着缓存折扣极大且输出很少（现实中不常见）

### 3.1 同步给出一个更好理解的量：有效单价

`P_eff = Pin * M`（$/1M 有效工作词）

这相当于：你在当前缓存/输出结构下，每“1M 有效工作词”实际花了多少钱。

---

## 4. 模拟用户行为（让倍率可对比）

目标：制造一组可重复的行为，使你能观察：

- 冷启动（缓存命中低）
- 重复提问（缓存命中高）
- 小改动（部分命中）
- 工具密集型（tool output 多，输出 token 变化）

建议按下面 4 个 Session 操作（每次都**新开一次 codex 会话**最清晰）：

### Session A：冷启动（低缓存）
1. 进入一个新目录（或清空上下文）
2. 提一个全新的、长一些的需求（例如让它分析一段新文本/新代码）
3. 结束会话

预期：`cached_input_tokens` 占比低，`U` 较大。

### Session B：重复提问（高缓存）
1. 立刻再开一个会话
2. **原样粘贴** Session A 的同一段需求
3. 结束会话

预期：`cached_input_tokens` 占比显著提高，`U` 明显下降。

### Session C：小改动（部分命中）
1. 再开一个会话
2. 用 Session A 的需求，但只改 5–10%（改一个参数/增加一句约束）
3. 结束会话

预期：缓存命中仍高，但 `U` 会比 Session B 大（因为发生了增量变化）。

### Session D：工具密集型（输出与工具调用）
1. 再开一个会话
2. 要求它执行一些 `exec_command`、解析输出并总结（例如 `rg`、`ls`、`docker ps`）
3. 结束会话

预期：`O`（输出）可能更大；倍率里 `r*O` 的影响更明显。

> 备注：这 4 个 session 只要你保证“提示词内容”一致/可控，就能做横向对比。

---

## 5. 计算方法（从 rollout JSONL 直接算）

我在本目录提供了脚本：`codex倍率计算.py`

用法示例（按某一天汇总所有 rollout）：

- 缓存不打折（`α=1`）：
  - `python3 codex倍率计算.py --date 2026-01-11 --pin 0.875 --pout 7 --alpha 1`
- 缓存按 0.1 计费（`α=0.1`）：
  - `python3 codex倍率计算.py --date 2026-01-11 --pin 0.875 --pout 7 --alpha 0.1`

输出包含：

- `I/C/U/O`
- 缓存命中率 `C/I`
- `E`、`W`
- 真实倍率 `M`
- 有效单价 `P_eff`
- 输入/输出成本拆分（$）

---

## 6. 用“今天日志”的示例（口径演示）

以下示例以“汇总当日所有 rollout 的 token”为准（你机器上的统计可能随新增会话变化）。

若设：

- `Pin=$0.8750/M`，`Pout=$7.0000/M` → `r=8`
- `α=0.1`

并从当天汇总得到 `I/C/U/O` 后：

1. 算 `E = U + 0.1*C + 8*O`
2. 算 `W = U + O`
3. 算 `M = E/W`
4. 算 `P_eff = Pin*M`

---

## 7. 注意事项（避免“看起来对但实际错”）

- `cached_input_tokens` 表示命中缓存的输入 token 数量；**是否折扣计费完全取决于你的计费规则**（用 `α` 控制）。
- 同一天多 session 汇总时，我建议用“按 session 求和”的方式做日汇总；它能反映“当天总行为”的结构。
- 不要用 `codex-tui.log` 去推成本：它未必包含完整 token 统计与输出；以 rollout JSONL 为准。

